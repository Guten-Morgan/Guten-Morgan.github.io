<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PWHL WAR Leaderboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:ital,wght@0,600;0,700;1,600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css">
  <style>
    /* ── Page shell ─────────────────────────────────────── */
    .war-hero {
      background: linear-gradient(135deg, var(--blue-dark) 0%, var(--blue) 60%, var(--blue-mid) 100%);
      padding: 100px 0 64px;
      color: var(--white);
      position: relative;
      overflow: hidden;
    }
    .war-hero::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse 60% 80% at 80% 50%, rgba(207,181,59,.12) 0%, transparent 70%);
      pointer-events: none;
    }
    .war-hero-inner {
      position: relative; z-index: 1;
    }
    .war-back {
      display: inline-flex; align-items: center; gap: .4rem;
      font-size: .8rem; font-weight: 500; letter-spacing: .06em; text-transform: uppercase;
      color: rgba(255,255,255,.6);
      margin-bottom: 1.5rem;
      transition: color var(--t);
    }
    .war-back:hover { color: var(--gold-light); }
    .war-back svg { width: 14px; height: 14px; }
    .war-hero h1 { font-family: var(--font-serif); font-size: clamp(2rem,4vw,3rem); margin-bottom: .5rem; }
    .war-hero p  { color: rgba(255,255,255,.72); font-size: 1.05rem; max-width: 560px; }
    .war-badge {
      display: inline-block;
      background: rgba(207,181,59,.18); border: 1px solid rgba(207,181,59,.4);
      color: var(--gold-light); font-size: .72rem; font-weight: 600; letter-spacing: .08em;
      text-transform: uppercase; padding: .25rem .75rem; border-radius: 100px;
      margin-bottom: 1rem;
    }

    /* ── Controls panel ──────────────────────────────────── */
    .war-controls {
      background: var(--white);
      border-bottom: 1px solid var(--border);
      padding: 28px 0;
      position: sticky; top: 66px; z-index: 90;
      box-shadow: var(--shadow-sm);
    }
    .controls-grid {
      display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: flex-end;
    }
    .control-group { display: flex; flex-direction: column; gap: .4rem; }
    .control-label {
      font-size: .7rem; font-weight: 600; letter-spacing: .1em; text-transform: uppercase;
      color: var(--text-3);
    }

    /* Season wheel */
    .season-wheel {
      display: flex; gap: 0;
      border: 1.5px solid var(--border); border-radius: var(--radius);
      overflow: hidden; background: var(--bg);
    }
    .season-btn {
      padding: .45rem 1.1rem;
      font-size: .85rem; font-weight: 500; color: var(--text-2);
      background: transparent; border: none;
      cursor: pointer; transition: background var(--t), color var(--t);
      border-right: 1px solid var(--border);
      white-space: nowrap;
      user-select: none;
    }
    .season-btn:last-child { border-right: none; }
    .season-btn:hover { background: var(--blue-pale); color: var(--blue); }
    .season-btn.active {
      background: var(--blue); color: var(--white); font-weight: 600;
    }

    /* Pill filters */
    .pill-group { display: flex; gap: .4rem; flex-wrap: wrap; }
    .pill-btn {
      padding: .35rem .85rem;
      font-size: .8rem; font-weight: 500;
      border: 1.5px solid var(--border); border-radius: 100px;
      background: var(--white); color: var(--text-2);
      cursor: pointer; transition: all var(--t);
    }
    .pill-btn:hover { border-color: var(--blue-light); color: var(--blue); }
    .pill-btn.active {
      background: var(--blue); border-color: var(--blue); color: var(--white);
      font-weight: 600;
    }

    /* Pos toggle */
    .pos-toggle { display: flex; gap: 0; border: 1.5px solid var(--border); border-radius: var(--radius); overflow: hidden; }
    .pos-btn {
      padding: .45rem 1rem; font-size: .85rem; font-weight: 500;
      border: none; background: transparent; color: var(--text-2);
      cursor: pointer; transition: background var(--t), color var(--t);
      border-right: 1px solid var(--border);
    }
    .pos-btn:last-child { border-right: none; }
    .pos-btn:hover { background: var(--blue-pale); color: var(--blue); }
    .pos-btn.active { background: var(--blue); color: var(--white); font-weight: 600; }

    /* ── Table section ───────────────────────────────────── */
    .war-section { padding: 48px 0 80px; }
    .war-meta {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 1rem; flex-wrap: wrap; gap: .5rem;
    }
    .war-count {
      font-size: .85rem; color: var(--text-3);
    }
    .war-count strong { color: var(--text); font-weight: 600; }
    .war-note {
      font-size: .75rem; color: var(--text-3); font-style: italic;
    }

    /* Table wrapper */
    .table-wrap {
      background: var(--white);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }
    table {
      width: 100%; border-collapse: collapse;
    }
    thead th {
      background: var(--blue-dark);
      color: rgba(255,255,255,.85);
      font-size: .72rem; font-weight: 600; letter-spacing: .08em; text-transform: uppercase;
      padding: .85rem 1rem;
      text-align: left; white-space: nowrap;
      cursor: pointer; user-select: none;
      transition: background var(--t);
    }
    thead th:hover { background: var(--blue-mid); color: var(--white); }
    thead th.sorted-asc::after  { content: " ▲"; opacity: .8; }
    thead th.sorted-desc::after { content: " ▼"; opacity: .8; }
    thead th.th-rank, thead th.th-gp { text-align: center; }
    thead th.th-war, thead th.th-owar, thead th.th-dwar, thead th.th-war60 { text-align: right; }

    tbody tr {
      border-bottom: 1px solid var(--border);
      transition: background var(--t);
    }
    tbody tr:last-child { border-bottom: none; }
    tbody tr:hover { background: var(--blue-pale); }

    td {
      padding: .7rem 1rem; font-size: .875rem; color: var(--text); vertical-align: middle;
    }
    td.td-rank {
      text-align: center; font-size: .8rem; font-weight: 700;
      color: var(--text-3); width: 52px;
    }
    td.td-rank.top3 { color: var(--gold-dark); }

    .player-cell { display: flex; flex-direction: column; gap: 1px; }
    .player-name { font-weight: 600; color: var(--text); }
    .player-seasons { font-size: .72rem; color: var(--text-3); }

    .team-chip {
      display: inline-block;
      font-size: .7rem; font-weight: 700; letter-spacing: .06em;
      padding: .2rem .55rem; border-radius: 5px;
      background: var(--blue-pale2); color: var(--blue);
    }
    .pos-chip {
      display: inline-block;
      font-size: .7rem; font-weight: 700;
      padding: .2rem .55rem; border-radius: 5px;
    }
    .pos-chip.F { background: #FEF3C7; color: #92400E; }
    .pos-chip.D { background: #DBEAFE; color: #1E40AF; }

    td.td-war, td.td-owar, td.td-dwar, td.td-war60 {
      text-align: right; font-variant-numeric: tabular-nums; font-weight: 500;
    }
    td.td-war { font-weight: 700; }
    td.td-war60 { color: var(--text-2); font-size: .88rem; }

    /* ── Scatter chart ───────────────────────────────────────── */
    .war-chart-wrap {
      background: var(--white);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px 24px 16px;
      margin-bottom: 24px;
      box-shadow: var(--shadow-sm);
    }
    .chart-header {
      display: flex; justify-content: space-between; align-items: baseline;
      flex-wrap: wrap; gap: .5rem;
      margin-bottom: 16px;
    }
    .chart-title {
      font-size: .78rem; font-weight: 700; letter-spacing: .09em;
      text-transform: uppercase; color: var(--text-2);
    }
    .chart-hint {
      font-size: .73rem; color: var(--text-3);
    }
    .war-bar-cell { width: 120px; }
    .war-bar-wrap { height: 6px; background: var(--border); border-radius: 3px; overflow: hidden; }
    .war-bar      { height: 100%; background: var(--gold); border-radius: 3px; transition: width .4s ease; }

    td.td-gp { text-align: center; color: var(--text-3); font-size: .82rem; }

    .dwar-pos { color: #15803D; }
    .dwar-neg { color: #B91C1C; }

    /* Empty state */
    .empty-state {
      text-align: center; padding: 64px 24px; color: var(--text-3);
    }
    .empty-state svg { width: 48px; height: 48px; opacity: .35; margin: 0 auto 1rem; }
    .empty-state p { font-size: .95rem; }

    /* Method note */
    .method-card {
      background: var(--blue-pale);
      border: 1px solid var(--blue-pale2);
      border-radius: var(--radius);
      padding: 1.25rem 1.5rem;
      margin-top: 2rem;
      font-size: .82rem; color: var(--text-2); line-height: 1.7;
    }
    .method-card strong { color: var(--text); }

    /* ── Refresh bar ─────────────────────────────────────── */
    .refresh-bar {
      background: var(--bg-tinted);
      border-bottom: 1px solid var(--border);
      padding: 8px 0;
      font-size: .78rem; color: var(--text-3);
    }
    .refresh-inner {
      display: flex; align-items: center; gap: .75rem; flex-wrap: wrap;
    }
    .refresh-status { flex: 1; }
    .refresh-status strong { color: var(--text-2); }
    .refresh-btn {
      display: inline-flex; align-items: center; gap: .35rem;
      padding: .3rem .85rem; border-radius: 100px;
      font-size: .75rem; font-weight: 600;
      background: var(--white); border: 1.5px solid var(--border);
      color: var(--blue); cursor: pointer;
      transition: all var(--t);
    }
    .refresh-btn:hover:not(:disabled) { background: var(--blue); color: var(--white); border-color: var(--blue); }
    .refresh-btn:disabled { opacity: .5; cursor: not-allowed; }
    .refresh-btn svg { width: 12px; height: 12px; }
    .refresh-btn.spinning svg { animation: spin .8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .refresh-progress {
      height: 2px; background: var(--border);
      position: relative; overflow: hidden; border-radius: 1px;
    }
    .refresh-progress-bar {
      height: 100%; background: var(--gold);
      border-radius: 1px; transition: width .3s ease;
      width: 0%;
    }

    @media (max-width: 640px) {
      .war-bar-cell, td.td-owar, td.td-dwar { display: none; }
      thead th.th-owar, thead th.th-dwar, thead th.th-bar { display: none; }
      .controls-grid { flex-direction: column; }
      .pill-group { gap: .3rem; }
    }
  </style>
</head>
<body>

  <!-- ===== NAV (matches portfolio) ===== -->
  <nav class="navbar" id="navbar" style="position:sticky;">
    <div class="nav-inner">
      <a href="index.html" class="nav-brand">
        <span class="brand-name">Portfolio</span>
        <span class="brand-sep">|</span>
        <span class="brand-role">PWHL WAR</span>
      </a>
      <ul class="nav-menu">
        <li><a href="index.html#projects" class="nav-link">Projects</a></li>
        <li><a href="index.html#blog"     class="nav-link">Writing</a></li>
        <li><a href="index.html#resume"   class="nav-link">Resume</a></li>
      </ul>
    </div>
  </nav>

  <!-- ===== HERO ===== -->
  <div class="war-hero">
    <div class="container war-hero-inner">
      <a href="index.html" class="war-back">
        <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 3L5 8l5 5"/></svg>
        Back to Portfolio
      </a>
      <div class="war-badge">Sports Analytics</div>
      <h1>PWHL WAR Leaderboard</h1>
      <p>xG-based Wins Above Replacement for PWHL skaters across all three seasons (2023–24 through 2025–26).</p>
    </div>
  </div>

  <!-- ===== CONTROLS ===== -->
  <div class="war-controls">
    <div class="container">
      <div class="controls-grid">

        <!-- Season wheel -->
        <div class="control-group">
          <span class="control-label">Season</span>
          <div class="season-wheel" id="seasonWheel" role="group" aria-label="Season selector">
            <button class="season-btn" data-season="2023">2023</button>
            <button class="season-btn" data-season="2024">2024</button>
            <button class="season-btn active" data-season="2025">2025</button>
          </div>
        </div>

        <!-- Team filter -->
        <div class="control-group">
          <span class="control-label">Team</span>
          <div class="pill-group" id="teamFilter"></div>
        </div>

        <!-- Position filter -->
        <div class="control-group">
          <span class="control-label">Position</span>
          <div class="pos-toggle" id="posFilter">
            <button class="pos-btn active" data-pos="ALL">All</button>
            <button class="pos-btn"        data-pos="F">F</button>
            <button class="pos-btn"        data-pos="D">D</button>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- ===== REFRESH BAR ===== -->
  <div class="refresh-bar" id="refreshBar">
    <div class="container">
      <div class="refresh-inner">
        <span class="refresh-status" id="refreshStatus">
          <strong>2025 data:</strong> loading…
        </span>
        <button class="refresh-btn" id="refreshBtn" disabled>
          <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M13.5 8A5.5 5.5 0 1 1 8 2.5c1.8 0 3.4.87 4.4 2.2"/>
            <path d="M13.5 2.5v2.7h-2.7"/>
          </svg>
          Refresh 2025
        </button>
      </div>
      <div class="refresh-progress" id="refreshProgress" style="display:none; margin-top:5px;">
        <div class="refresh-progress-bar" id="refreshProgressBar"></div>
      </div>
    </div>
  </div>

  <!-- ===== TABLE ===== -->
  <section class="war-section">
    <div class="container">
      <div class="war-meta">
        <p class="war-count" id="warCount"></p>
        <p class="war-note" id="warNote"></p>
      </div>

      <div class="war-chart-wrap">
        <div class="chart-header">
          <span class="chart-title">WAR vs xG/60</span>
          <span class="chart-hint">Top-left = high rate, limited ice time &nbsp;·&nbsp; Top-right = elite &nbsp;·&nbsp; min 50 TOI (2025) / 100 TOI (full seasons)</span>
        </div>
        <canvas id="warChartCanvas"></canvas>
      </div>

      <div class="table-wrap">
        <table id="warTable">
          <thead>
            <tr>
              <th class="th-rank">#</th>
              <th data-col="name">Player</th>
              <th data-col="team">Team</th>
              <th data-col="pos">Pos</th>
              <th class="th-gp" data-col="gp">GP</th>
              <th class="th-owar" data-col="owar">oWAR</th>
              <th class="th-dwar" data-col="dwar">dWAR</th>
              <th class="th-war sorted-desc" data-col="war">WAR</th>
              <th class="th-war60" data-col="oxg60" title="Offensive expected goals per 60 min — shot-generation rate, independent of ice time and defense">xG/60</th>
              <th class="th-bar war-bar-cell"></th>
            </tr>
          </thead>
          <tbody id="warBody"></tbody>
        </table>
      </div>

      <div class="method-card">
        <strong>Method:</strong>
        Offensive value = individual xG per 60 min (EV + PP + SH).
        Defensive value = residual plus/minus per 60 min (OLS-orthogonalized to remove offensive contamination), weighted at 0.1.
        WAR = oWAR + dWAR (signed — good defense adds value, poor defense subtracts).
        Replacement level = 25th percentile of each component.
        xG/60 = individual offensive expected goals per 60 min — pure shot-generation rate, independent of ice time and the defensive component, so it ranks differently from WAR.
        Goals-per-win: 4.57 (2023), 5.05 (2024), 4.51 (2025).
        When multiple seasons are selected, WAR and xG/60 are averaged across seasons played.
        <strong>2025 season is partial</strong> (61/120 games) and uses an approximated xG model from shot-quality categories.
      </div>
    </div>
  </section>

  <footer class="footer">
    <div class="container footer-inner">
      <p class="footer-copy">&copy; 2026 · PWHL WAR Model · Data from hockey-statistics.com</p>
      <div class="footer-links">
        <a href="index.html" class="footer-link">Portfolio</a>
      </div>
    </div>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="js/pwhl-data.js"></script>
  <script>
  // ════════════════════════════════════════════════════════════════
  //  PWHL 2025 Live Refresh Engine
  //  Fetches directly from pwhl.hockey-statistics.com (public API)
  //  and re-computes the WAR model entirely in the browser.
  // ════════════════════════════════════════════════════════════════
  const REFRESH = (() => {
    const API   = "https://pwhl.hockey-statistics.com/api";
    const KEY   = "pwhl_2025_cache";
    const CACHE_TTL_MS = 6 * 60 * 60 * 1000;  // 6-hour cache

    const XG = {
      "Non quality on net": 0.051034,
      "Quality on net":     0.094262,
      "Quality goal":       0.159976,
      "Non quality goal":   0.191898,
    };
    const TEAM_MAP = {
      "Boston Fleet":"BOS","Minnesota Frost":"MIN",
      "Montr\u00e9al Victoire":"MTL","New York Sirens":"NY",
      "Ottawa Charge":"OTT","Toronto Sceptres":"TOR",
      "Seattle Torrent":"SEA","Vancouver Goldeneyes":"VAN",
    };
    const MIN_TOI   = 25;
    const REPL_PCT  = 25;
    const DEF_W     = 0.1;

    // ── Maths helpers ────────────────────────────────────────────
    function pctile(arr, p) {
      const s = [...arr].sort((a,b)=>a-b);
      const idx = (p/100)*(s.length-1);
      const lo=Math.floor(idx), hi=Math.ceil(idx);
      return s[lo] + (s[hi]-s[lo])*(idx-lo);
    }
    function wMean(vals, wts) {
      let sw=0, sv=0;
      vals.forEach((v,i)=>{ sw+=wts[i]; sv+=v*wts[i]; });
      return sw ? sv/sw : 0;
    }
    function ols(xs, ys) {
      const n=xs.length;
      const mx=xs.reduce((a,b)=>a+b)/n, my=ys.reduce((a,b)=>a+b)/n;
      let num=0, den=0;
      xs.forEach((x,i)=>{ num+=(x-mx)*(ys[i]-my); den+=(x-mx)**2; });
      const slope = den ? num/den : 0;
      return { slope, intercept: my - slope*mx };
    }
    function pidFromUrl(url) {
      try { return parseInt(url.split("/").pop()); } catch { return 0; }
    }
    function parseTOI(s) {
      if (!s) return 0;
      const [m,sec] = s.split(":");
      return parseInt(m)+parseInt(sec)/60;
    }
    function posGroup(p) {
      p = (p||"").toUpperCase();
      if (p==="G") return "G";
      if (["LD","RD","D"].includes(p)) return "D";
      return "F";
    }

    // ── Batch fetch with concurrency limit ───────────────────────
    async function batchFetch(urls, concurrency=6) {
      const results=[], queue=[...urls];
      async function worker() {
        while (queue.length) {
          const url=queue.shift();
          try { results.push(await fetch(url).then(r=>r.json())); }
          catch { results.push(null); }
        }
      }
      await Promise.all(Array.from({length:concurrency}, worker));
      return results;
    }

    // ── Compute WAR from aggregated player map ───────────────────
    function computeWAR(players, gpw) {
      const rows = Object.values(players).filter(p => p.pos!=="G");

      rows.forEach(p => {
        p.o_xG60   = p.toi > 0.1 ? (p.ixG / p.toi * 60) : 0;
        p.pm60     = p.toi > 0.1 ? (p.pm  / p.toi * 60) : 0;
      });

      const qual = rows.filter(p => p.toi >= MIN_TOI);
      if (qual.length < 2) return [];

      const { slope, intercept } = ols(qual.map(p=>p.o_xG60), qual.map(p=>p.pm60));

      rows.forEach(p => {
        p.pm60_resid = p.pm60 - (intercept + slope*p.o_xG60);
      });

      const leagueResid = wMean(qual.map(p=>p.pm60_resid), qual.map(p=>p.toi));
      rows.forEach(p => {
        p.d_adj  = p.pm60_resid - leagueResid;
        p.d_val60 = p.d_adj * DEF_W;
        p.val60   = p.o_xG60 + p.d_val60;
      });

      const o_repl = pctile(qual.map(p=>p.o_xG60),  REPL_PCT);
      const d_repl = pctile(qual.map(p=>p.d_val60), REPL_PCT);

      rows.forEach(p => {
        p.oGAR = (p.o_xG60  - o_repl) * p.toi / 60;
        p.dGAR = (p.d_val60 - d_repl) * p.toi / 60;
        p.oWAR = p.oGAR / gpw;
        p.dWAR = p.dGAR / gpw;
        p.WAR  = p.oWAR + p.dWAR;
      });

      return rows.map(p => ({
        id:    p.id,
        name:  p.name,
        team:  p.team,
        pos:   p.pos,
        gp:    p.gp,
        toi:   Math.round(p.toi*10)/10,
        war:   Math.round(p.WAR*1000)/1000,
        owar:  Math.round(p.oWAR*1000)/1000,
        dwar:  Math.round(p.dWAR*1000)/1000,
        oxg60: Math.round(p.o_xG60*1000)/1000,
      }));
    }

    // ── Main refresh ─────────────────────────────────────────────
    async function run(onProgress) {
      onProgress(0, "Fetching schedule…");

      const schedResp = await fetch(`${API}/schedule`).then(r=>r.json());
      const games2025 = schedResp.games.filter(
        g => g.season_year==="2025/2026" && g.status.startsWith("Final")
      );
      const gameIds = games2025.map(g=>parseInt(g.game_id));

      // Build team abbr map from schedule
      const teamMap = {};
      schedResp.games.forEach(g=>{
        teamMap[g.home_team] = TEAM_MAP[g.home_team] || g.home_team;
        teamMap[g.away_team] = TEAM_MAP[g.away_team] || g.away_team;
      });
      const gameTeams={};
      schedResp.games.forEach(g=>{
        gameTeams[parseInt(g.game_id)] = {
          home: teamMap[g.home_team], away: teamMap[g.away_team]
        };
      });

      const total = gameIds.length;
      onProgress(5, `Fetching ${total} games…`);

      // Fetch PBP + Summary in parallel (split into two batches)
      const pbpUrls  = gameIds.map(id=>`${API}/game/playbyplay/${id}`);
      const summUrls = gameIds.map(id=>`${API}/game/summary/${id}`);

      let done=0;
      const tick = () => { done++; onProgress(5 + Math.round(done/(total*2)*85), null); };

      // fetch both sets concurrently but track progress
      const [pbpResults, summResults] = await Promise.all([
        (async()=>{ const r=[]; for (const u of pbpUrls) { try{r.push(await fetch(u).then(x=>x.json()));}catch{r.push(null);} tick(); } return r; })(),
        (async()=>{ const r=[]; for (const u of summUrls) { try{r.push(await fetch(u).then(x=>x.json()));}catch{r.push(null);} tick(); } return r; })(),
      ]);

      onProgress(92, "Computing WAR…");

      // Aggregate player data
      const players={};
      const teamIdToAbbr={};
      let totalGoals=0, nTeamGames=0;

      gameIds.forEach((gid, gi) => {
        const pbp  = pbpResults[gi];
        const summ = summResults[gi];
        if (!pbp || !summ) return;

        const gt = gameTeams[gid] || {};

        // Collect team_id → abbr from goal events
        pbp.forEach(e => {
          if (e.event==="goal") {
            const t=e.details?.team;
            if (t?.id && t?.abbreviation) teamIdToAbbr[String(t.id)]=t.abbreviation;
          }
        });

        // ixG from shot events
        const ixgMap={};
        pbp.forEach(e => {
          if (e.event!=="shot") return;
          const pid=e.details?.shooter?.id;
          const xg=XG[e.details?.shotQuality] || 0;
          if (pid) ixgMap[pid]=(ixgMap[pid]||0)+xg;
        });

        // pid → team from shot events
        const pidTeam={};
        pbp.forEach(e => {
          if (e.event==="shot") {
            const pid=e.details?.shooter?.id;
            const tid=String(e.details?.shooterTeamId||"");
            if (pid && teamIdToAbbr[tid]) pidTeam[pid]=teamIdToAbbr[tid];
          }
          if (e.event==="goal") {
            const pid=e.details?.scoredBy?.id;
            const tid=String(e.details?.team?.id||"");
            if (pid && teamIdToAbbr[tid]) pidTeam[pid]=teamIdToAbbr[tid];
          }
        });

        // Goals and goal count
        pbp.forEach(e => {
          if (e.event==="goal") totalGoals++;
        });

        // Summaries
        ["homeTeam","visitingTeam"].forEach((side, si) => {
          const defAbbr = si===0 ? gt.home : gt.away;
          ["skaters","goalies"].forEach(pk => {
            (summ[side]?.[pk]||[]).forEach(p => {
              const pid=pidFromUrl(p.playerImageURL||"");
              if (!pid) return;
              const pos=posGroup(p.position);
              const st=p.stats||{};
              const toi=parseTOI(st.toi||st.timeOnIce||"");
              const team=pidTeam[pid]||defAbbr||"UNK";
              const key=`${pid}|${team}`;
              if (!players[key]) players[key]={id:pid,name:p.name||"",team,pos,gp:0,toi:0,ixG:0,pm:0};
              if (toi>0) { players[key].gp++; players[key].toi+=toi; }
              players[key].ixG  += ixgMap[pid]||0;
              players[key].pm   += st.plusMinus||0;
            });
          });
          nTeamGames++;
        });
      });

      // goals_per_win from season data
      const avgGoalsPerTeam = nTeamGames ? totalGoals/nTeamGames : 2.25;
      const gpw = 2*avgGoalsPerTeam;

      const warRows = computeWAR(players, gpw);
      onProgress(100, "Done");
      return { rows: warRows, gpw, gameCount: gameIds.length, ts: Date.now() };
    }

    // ── Public API ───────────────────────────────────────────────
    return {
      loadCache() {
        try {
          const raw = localStorage.getItem(KEY);
          if (!raw) return null;
          const cached = JSON.parse(raw);
          if (Date.now()-cached.ts > CACHE_TTL_MS) return null;
          return cached;
        } catch { return null; }
      },
      saveCache(data) {
        try { localStorage.setItem(KEY, JSON.stringify(data)); } catch {}
      },
      run
    };
  })();
  </script>
  <script>
  (function () {
    // ── State ───────────────────────────────────────────────────────
    let selectedSeasons = new Set(["2025"]);
    let selectedTeam    = "ALL";
    let selectedPos     = "ALL";
    let sortCol         = "war";
    let sortDir         = -1;  // -1 = desc

    // ── Teams per season ────────────────────────────────────────────
    function allTeams() {
      const ts = new Set();
      for (const [s, rows] of Object.entries(PWHL_DATA)) {
        rows.forEach(r => ts.add(r.team));
      }
      return [...ts].sort();
    }

    // ── Build team filter pills ─────────────────────────────────────
    function buildTeamFilter() {
      const wrap = document.getElementById("teamFilter");
      wrap.innerHTML = "";
      const teams = allTeams();
      ["ALL", ...teams].forEach(t => {
        const btn = document.createElement("button");
        btn.className = "pill-btn" + (t === selectedTeam ? " active" : "");
        btn.textContent = t === "ALL" ? "All" : t;
        btn.dataset.team = t;
        btn.addEventListener("click", () => {
          selectedTeam = t;
          wrap.querySelectorAll(".pill-btn").forEach(b => b.classList.toggle("active", b.dataset.team === t));
          render();
        });
        wrap.appendChild(btn);
      });
    }

    // ── Aggregate rows across selected seasons ───────────────────────
    function aggregateRows() {
      if (selectedSeasons.size === 0) return [];
      const seasons = [...selectedSeasons];
      const players = {};  // key = `${id}|${team}` → aggregated

      seasons.forEach(s => {
        const rows = PWHL_DATA[s] || [];
        rows.forEach(r => {
          const key = `${r.id}|${r.name}`;
          if (!players[key]) {
            players[key] = { ...r, _wars: [], _owars: [], _dwars: [], _oxg60s: [], _seasons: [], _gp: 0 };
          }
          players[key]._wars.push(r.war);
          players[key]._owars.push(r.owar);
          players[key]._dwars.push(r.dwar);
          players[key]._oxg60s.push(r.oxg60 ?? 0);
          players[key]._seasons.push(s);
          players[key]._gp += r.gp;
        });
      });

      return Object.values(players).map(p => ({
        ...p,
        war:   avg(p._wars),
        owar:  avg(p._owars),
        dwar:  avg(p._dwars),
        oxg60: avg(p._oxg60s),
        gp:    p._gp,
        seasons: p._seasons.sort(),
      }));
    }

    function avg(arr) {
      return arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
    }

    // ── Filter ──────────────────────────────────────────────────────
    function applyFilters(rows) {
      return rows.filter(r => {
        if (selectedTeam !== "ALL" && r.team !== selectedTeam) return false;
        if (selectedPos  !== "ALL" && r.pos  !== selectedPos)  return false;
        return true;
      });
    }

    // ── Sort ────────────────────────────────────────────────────────
    function applySort(rows) {
      return [...rows].sort((a, b) => {
        const va = a[sortCol], vb = b[sortCol];
        if (typeof va === "string") return sortDir * va.localeCompare(vb);
        return sortDir * (va - vb);
      });
    }

    // ── Render ──────────────────────────────────────────────────────
    function render() {
      const agg    = aggregateRows();
      const filt   = applyFilters(agg);
      const sorted = applySort(filt);
      renderChart(filt);
      const maxWar = sorted.length ? sorted[0].war : 1;

      const tbody = document.getElementById("warBody");
      if (sorted.length === 0) {
        tbody.innerHTML = `<tr><td colspan="10">
          <div class="empty-state">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="12" cy="12" r="10"/><path d="M12 8v4m0 4h.01"/>
            </svg>
            <p>No players match the current filters.</p>
          </div></td></tr>`;
      } else {
        const multi = selectedSeasons.size > 1;
        tbody.innerHTML = sorted.map((r, i) => {
          const rank = i + 1;
          const dCls = r.dwar >= 0 ? "dwar-pos" : "dwar-neg";
          const dSign = r.dwar >= 0 ? "+" : "";
          const barPct = Math.min(100, (r.war / maxWar) * 100).toFixed(1);
          const seasonLabel = multi ? r.seasons.join(", ") : "";
          return `
            <tr>
              <td class="td-rank${rank <= 3 ? " top3" : ""}">${rank}</td>
              <td>
                <div class="player-cell">
                  <span class="player-name">${esc(r.name)}</span>
                  ${seasonLabel ? `<span class="player-seasons">${seasonLabel}</span>` : ""}
                </div>
              </td>
              <td><span class="team-chip">${esc(r.team)}</span></td>
              <td><span class="pos-chip ${r.pos}">${r.pos}</span></td>
              <td class="td-gp">${r.gp}</td>
              <td class="td-owar">${r.owar.toFixed(3)}</td>
              <td class="td-dwar ${dCls}">${dSign}${r.dwar.toFixed(3)}</td>
              <td class="td-war">${r.war.toFixed(3)}</td>
              <td class="td-war60">${(r.oxg60 ?? 0).toFixed(3)}</td>
              <td class="war-bar-cell">
                <div class="war-bar-wrap">
                  <div class="war-bar" style="width:${barPct}%"></div>
                </div>
              </td>
            </tr>`;
        }).join("");
      }

      // Meta line
      const multi = selectedSeasons.size > 1;
      const sLabel = [...selectedSeasons].sort().map(s => s + "-" + String(parseInt(s)+1).slice(-2)).join(", ");
      document.getElementById("warCount").innerHTML =
        `<strong>${sorted.length}</strong> players · Season${selectedSeasons.size > 1 ? "s" : ""}: <strong>${sLabel}</strong>`;
      document.getElementById("warNote").textContent =
        multi ? "WAR averaged across selected seasons" : (selectedSeasons.has("2025") ? "2025 = partial season (61/120 games)" : "");
    }

    function esc(s) {
      return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
    }

    // ── Scatter chart ────────────────────────────────────────────────
    let warChart = null;

    function renderChart(rows) {
      const canvas = document.getElementById("warChartCanvas");
      if (!canvas) return;

      if (warChart) { warChart.destroy(); warChart = null; }
      if (!rows.length) return;

      // Double the data-generation TOI floor to filter outliers from the chart
      // 2025-26 (partial) was generated at 25 min → chart uses 50 min
      // Full seasons were generated at 50 min → chart uses 100 min
      const only2025 = selectedSeasons.size === 1 && selectedSeasons.has("2025");
      const chartMinToi = only2025 ? 50 : 100;
      const chartRows = rows.filter(r => r.toi >= chartMinToi);
      if (!chartRows.length) return;

      const fRows = chartRows.filter(r => r.pos === "F");
      const dRows = chartRows.filter(r => r.pos === "D");
      const toPoint = r => ({ x: r.war, y: r.oxg60 ?? 0, name: r.name, team: r.team });

      const allX   = chartRows.map(r => r.war);
      const allY   = chartRows.map(r => r.oxg60 ?? 0);
      const minX   = Math.min(...allX, -0.05) - 0.12;
      const maxX   = Math.max(...allX,  0.05) + 0.12;
      const minY   = Math.max(0, Math.min(...allY) - 0.05);
      const maxY   = Math.max(...allY) + 0.12;
      const avgY   = allY.reduce((a, b) => a + b, 0) / allY.length;

      // Quadrant label plugin (drawn on the canvas after Chart.js renders)
      const quadPlugin = {
        id: "quadLabels",
        afterDraw(chart) {
          const { ctx, chartArea: ca, scales: { x, y } } = chart;
          const x0  = x.getPixelForValue(0);
          const yA  = y.getPixelForValue(avgY);
          ctx.save();
          ctx.font = "10px Inter, sans-serif";
          ctx.fillStyle = "rgba(140,140,140,0.75)";
          // Top-left quadrant label
          ctx.textAlign = "left";
          if (x0 - ca.left > 80)
            ctx.fillText("High rate, low TOI", ca.left + 6, ca.top + 14);
          // Top-right quadrant label
          ctx.textAlign = "right";
          if (ca.right - x0 > 60)
            ctx.fillText("Elite", ca.right - 6, ca.top + 14);
          ctx.restore();
        }
      };

      warChart = new Chart(canvas.getContext("2d"), {
        type: "scatter",
        plugins: [quadPlugin],
        data: {
          datasets: [
            {
              label: "Forwards",
              data: fRows.map(toPoint),
              backgroundColor: "rgba(43,82,182,0.5)",
              borderColor:     "rgba(43,82,182,0.8)",
              pointRadius: 5, pointHoverRadius: 7,
            },
            {
              label: "Defense",
              data: dRows.map(toPoint),
              backgroundColor: "rgba(207,181,59,0.6)",
              borderColor:     "rgba(170,145,30,0.9)",
              pointRadius: 5, pointHoverRadius: 7,
            },
            // WAR = 0 vertical reference line
            {
              type: "line", label: "_v",
              data: [{ x: 0, y: minY }, { x: 0, y: maxY }],
              borderColor: "rgba(150,150,150,0.4)", borderWidth: 1.2,
              borderDash: [5, 4], pointRadius: 0, fill: false,
            },
            // avg xG/60 horizontal reference line
            {
              type: "line", label: "_h",
              data: [{ x: minX, y: avgY }, { x: maxX, y: avgY }],
              borderColor: "rgba(150,150,150,0.4)", borderWidth: 1.2,
              borderDash: [5, 4], pointRadius: 0, fill: false,
            },
          ]
        },
        options: {
          responsive: true,
          aspectRatio: 2.2,
          interaction: { mode: "nearest", intersect: true },
          plugins: {
            legend: {
              position: "top",
              labels: {
                filter: item => !item.text.startsWith("_"),
                boxWidth: 10, padding: 14,
                font: { size: 11, family: "Inter, sans-serif" },
                color: "#555",
              }
            },
            tooltip: {
              callbacks: {
                title: () => "",
                label: ctx => {
                  const d = ctx.raw;
                  return [
                    `${d.name}  ·  ${d.team}`,
                    `WAR: ${d.x.toFixed(3)}`,
                    `xG/60: ${d.y.toFixed(3)}`,
                  ];
                }
              }
            }
          },
          scales: {
            x: {
              min: minX, max: maxX,
              title: { display: true, text: "WAR", font: { size: 11 }, color: "#999" },
              grid: { color: "rgba(0,0,0,0.05)" },
              ticks: { font: { size: 11 }, color: "#888" },
            },
            y: {
              min: minY, max: maxY,
              title: { display: true, text: "xG / 60 min", font: { size: 11 }, color: "#999" },
              grid: { color: "rgba(0,0,0,0.05)" },
              ticks: { font: { size: 11 }, color: "#888" },
            }
          }
        }
      });
    }

    // ── Season wheel ────────────────────────────────────────────────
    document.getElementById("seasonWheel").addEventListener("click", e => {
      const btn = e.target.closest(".season-btn");
      if (!btn) return;
      const s = btn.dataset.season;
      if (selectedSeasons.has(s)) {
        if (selectedSeasons.size === 1) return;  // keep at least 1
        selectedSeasons.delete(s);
        btn.classList.remove("active");
      } else {
        selectedSeasons.add(s);
        btn.classList.add("active");
      }
      render();
    });

    // ── Position filter ──────────────────────────────────────────────
    document.getElementById("posFilter").addEventListener("click", e => {
      const btn = e.target.closest(".pos-btn");
      if (!btn) return;
      selectedPos = btn.dataset.pos;
      document.querySelectorAll(".pos-btn").forEach(b => b.classList.toggle("active", b.dataset.pos === selectedPos));
      render();
    });

    // ── Column sort ─────────────────────────────────────────────────
    document.querySelectorAll("thead th[data-col]").forEach(th => {
      th.addEventListener("click", () => {
        const col = th.dataset.col;
        if (sortCol === col) sortDir *= -1;
        else { sortCol = col; sortDir = typeof PWHL_DATA["2025"][0]?.[col] === "string" ? 1 : -1; }
        document.querySelectorAll("thead th").forEach(h => h.classList.remove("sorted-asc","sorted-desc"));
        th.classList.add(sortDir === 1 ? "sorted-asc" : "sorted-desc");
        render();
      });
    });

    // ── Refresh UI wiring ────────────────────────────────────────────
    const statusEl  = document.getElementById("refreshStatus");
    const btnEl     = document.getElementById("refreshBtn");
    const progressEl= document.getElementById("refreshProgress");
    const barEl     = document.getElementById("refreshProgressBar");

    function setStatus(ts, gameCount, gpw) {
      const d = new Date(ts);
      const ago = Math.round((Date.now()-ts)/60000);
      const agoTxt = ago < 2 ? "just now" : ago < 60 ? `${ago}m ago` : `${Math.round(ago/60)}h ago`;
      statusEl.innerHTML =
        `<strong>2025 data:</strong> ${gameCount} games · gpw ${gpw.toFixed(2)} · updated ${agoTxt}`;
      btnEl.disabled = false;
    }

    function setProgress(pct, msg) {
      progressEl.style.display = pct < 100 && pct > 0 ? "block" : "none";
      barEl.style.width = pct + "%";
      if (msg) statusEl.innerHTML = `<strong>2025 data:</strong> ${msg}`;
    }

    async function doRefresh() {
      btnEl.disabled = true;
      btnEl.classList.add("spinning");
      progressEl.style.display = "block";
      try {
        const result = await REFRESH.run(setProgress);
        PWHL_DATA["2025"] = result.rows;
        REFRESH.saveCache(result);
        setStatus(result.ts, result.gameCount, result.gpw);
        buildTeamFilter();
        render();
      } catch (err) {
        statusEl.innerHTML = `<strong>2025 data:</strong> Refresh failed — ${err.message}`;
        btnEl.disabled = false;
      }
      btnEl.classList.remove("spinning");
      progressEl.style.display = "none";
    }

    btnEl.addEventListener("click", doRefresh);

    // On load: try cache first, then show static data
    (function initRefresh() {
      const cached = REFRESH.loadCache();
      if (cached) {
        PWHL_DATA["2025"] = cached.rows;
        setStatus(cached.ts, cached.gameCount, cached.gpw);
        render();
      } else {
        statusEl.innerHTML = `<strong>2025 data:</strong> Using bundled snapshot · click Refresh for latest`;
        btnEl.disabled = false;
      }
    })();

    // ── Init ────────────────────────────────────────────────────────
    buildTeamFilter();
    render();
  })();
  </script>
</body>
</html>
